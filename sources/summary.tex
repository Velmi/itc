\section{Einleitung}

\subsection{Informationstheorie}

Bit: binary unit $\rightarrow$ Einheit für Information

bit: binary digit $\rightarrow$ bit als binäres Symbol

\textbf{Informationgehalt} 

je unwahrscheinlicher ein Symbol $x$ auftritt, desto mehr Information enhält es:

$\displaystyle{
    I(x) = ld\left( \frac{1}{P(x)} \right) = -ld(P(x))
}$

$P$: Wahrscheinlichkeit eines Symbols\\
$I$: Informationsgehalt $[I] = Bit$

\textbf{Entropie}

gemittelter Informationsgehalt einer Quelle $X$:

$\displaystyle{
    H(X) = \sum_{i} P(x_i) \cdot I(x_i) = - \sum_{i} P(x_i) \cdot ld(P(x_i))
}$

$H$: Entropie $[H] = Bit/Symbol$

\textbf{Entscheidungsgehalt}

Entropie wird maximal, wenn alle Symbole gleichwahrscheinlich sind
$\rightarrow$ Entscheidungsgehalt

$\displaystyle{
    H_0 = ld(N)
}$

$H_0$: Entscheidungsgehalt $[H_0] = Bit/Symbol$\\
$N$: Anzahl der Symbole eines Alphabets

\textbf{Redundanz}

$\displaystyle{
    R = H_0 - H
}$

$\displaystyle{
    r = \frac{R}{H_0}
}$

$R$: Redundanz $[R] = Bit/Symbol$\\
$r$: relative Redundanz

%%//TODO: mittlere Laenge Code

\subsection{Quellcodierung}

\subsubsection{Huffman-Code}

ist \textbf{Präfixcode:} ein Codewort ist niemals Anfang eines anderen Codewortes

Codebaum aufbauen:
\begin{enumerate}
    \item Ordne die Symbole nach Auftrittswahrscheinlichkeit
    \item Fasse Symbole mit niedrigster Wahrscheinlichkeit zu einem Symbol zusammen und addiere die Wahrscheinlichkeiten
    \item Wiederhole bis nur ein Symbol übrig bleibt
\end{enumerate}

Beschrifte die Pfade mit 1 und 0\\
$\rightarrow$ Codewort ergibt sich, indem man von Wurzel bis zum Blatt geht

\includegraphics[width=6cm]{img/huffman.PNG}

\underline{Hinweis}: Beschriftung der 0; 1 theoretisch egal aber für Überprüfung mit Onlinerechnern
sollte konsistent der Pfad mit der geringeren und höheren Wahrscheinlichkeit gleich beschriftet
werden

\subsubsection{Arithmetische Codierung}

Codierung eines Wortes (oder Textes) durch Zahl

Endezeichen notwendig, da keine natürliche Terminierung des Codes

\subsection{Kanalmodell}

\subsection{Kanalkapazität}

\subsection{Shannon-Theoreme}

\section{Blockcodes}

Code beschrieben durch $C(n, k, d)$

$n$: Länge Codewort\\
$k$: Länge Informationswort\\
$d$: Mindestabstand

Coderate: 
$\displaystyle{
    CR = \frac{k}{n}
}$

\subsection{Generelles}

\textbf{Generatormatrix}

Erzeugung eines Codewortes über Multiplikation eines Informationsvektors

$\displaystyle{
    \vec{c} = i \cdot G
}$

$c$: Codewort\\
$i$: Informationswort\\
$G$: Generatormatrix

\textbf{Prüfmatrix}

$\displaystyle{
    \vec{c}^T  H = 0
}$

$\displaystyle{
    H \cdot G^T
}$

$H$: Prüfmatrix

\textbf{Syndrom}

wenn Empfangswort $r$ fehlerhaft ist (damit nicht zum Coderaum gehört) dann ist das Produkt aus
Prüfmatrix und Empfangswort das \textit{Syndrom} und nicht mehr 0

$\displaystyle{
    \vec{r}^T  H = \vec{s} \neq 0
}$

\textbf{Systematische Codes}

Systematischer Code: Einheitsmatrix $I$ ist Teil der Generatormatrix

$\displaystyle{
    G = [I | G']
}$

Bsp.: C(7, 4, 3): 
$\displaystyle{
    G =
    \begin{pmatrix}
        1 & 0 & 0 & 0 & 0 & 1 & 1\\
        0 & 1 & 0 & 0 & 1 & 0 & 1\\
        0 & 0 & 1 & 0 & 1 & 1 & 0\\
        0 & 0 & 0 & 1 & 1 & 1 & 1
    \end{pmatrix}
}$

\textbf{Lineare Codes}

%//TODO

\textbf{Gewicht}

Gewicht eines Codewortes: Anzahl der von 0 verschiedenen Stellen

Mindestgewicht: Minimale Anzahl an Stellen, die von 0 verschieden sind

\textbf{Distanz/Abstand}

Hamming-Distanz: Anzahl an verschiedenen Stellen zweier Codewörter

Mindestdistanz: Mindestanzahl an verschiedenen Stellen zweier beliebiger Codewörter eines Codes

bei linearen Codes: Mindestgewicht = Mindestabstand

\textbf{Fehlerkorrigierbarkeit/Fehlererkennung}

%//TODO

\subsection{Hamming-Codes}

immer $d=3$

$\displaystyle{
    n = 2^h - 1
}$

$\displaystyle{
    k = n - h
}$

\begin{tabular}{c|c c c}
    h & n & k & d\\
    \hline
    2 & 3 & 1 & 3\\
    3 & 7 & 4 & 3\\
    4 & 15 & 11 & 3\\
    5 & 31 & 26 & 3\\
    \vdots & \vdots & \vdots & \vdots
\end{tabular}

\textbf{Konstruktion}

\section{Galois-Felder}
\label{sec:galois}

\subsection{Algebraische Strukturen}

\includegraphics[width=8cm]{img/algebraische_strukturen.PNG}

\textbf{Menge}

Verbund von Elementen, welche keine Operationen beinhalten (Möbel können eine Menge sein, es kann aber nicht Tisch + Stuhl gerechnet werden)

\textbf{Halbgruppe}

Menge $A$ mit Verknüpfung \frqq +\flqq{} ist eine Halbgruppe, wenn
\begin{itemize}
    \item Abgeschlossenheit (+ zweier Elemente von $A$ ergibt wieder ein Element von $A$)
    \item Assoziativität (Reihenfolge der Operation mit + spielt keine Rolle, $a + (b + c) = (a + b) + c$)
    \item Existenz eines neutralen Elements (Element $a$ + neutrales Element $n$ ergibt wieder Element $a$)
\end{itemize}

\textbf{Gruppe}

Halbgruppe plus
\begin{itemize}
    \item Existenz eines additiven inversen Elements ($a + b = n$)
\end{itemize}

\textbf{Abelsche oder kommutative Gruppe}

Gruppe plus
\begin{itemize}
    \item Kommutativität (Reihenfolge der Operanden spielt keine Rolle, $a + b = b + a$)
\end{itemize}

\textbf{Ring}

abelsche Gruppe plus
\begin{itemize}
    \item Abgeschlossenheit bezüglich \frqq $\cdot$\flqq
    \item Assoziativität bezüglich \frqq $\cdot$\flqq
    \item Distributivität ($a \cdot (b + c) = a \cdot b + a \cdot c$)
\end{itemize}

\textbf{Körper}

Ring plus
\begin{itemize}
    \item Kommutativität bezüglich \frqq $\cdot$\flqq ($a \cdot b = b \cdot a$)
    \item Neutrales Element bezüglich \frqq $\cdot$\flqq
    \item Inverses Element bezüglich \frqq $\cdot$\flqq für jedes Element
\end{itemize}

\textbf{Primkörper/Galois-Feld}

Körper, indem Addition und Multiplikation $\mod p$ gerechnet wird ($p$ muss dabei eine Primzahl sein)\\
$\hookrightarrow GF(p)$

\subsection{Eigenschaften Galois-Felder}

\textbf{Primitives Element}

Element $\alpha$, welches durch ihre $p-1$ Potenzen alle Elemente (außer $0$) des $GF(p)$ erzeugt

Bsp. $GF(5), \alpha = 2$:

$2^0 = 1 \mod 5 = 1$\\
$2^1 = 2 \mod 5 = 2$\\
$2^2 = 4 \mod 5 = 4$\\
$ 2^3 = 8 \mod 5 = 3$

ab hier zykische Wiederholung:\\
$2^4 = 16 \mod 5 = 1$

\textbf{Polynome}

Folge an $n$ Zahlen im Galois-Feld wird als Polynom vom Grad $n-1$ geschrieben

$\displaystyle{
    \hookrightarrow \{ 1; 4; 3; 1 \} \rightarrow A(x) = 1x^3 + 4x^2 + 3x + 1
}$

Auswertung des Polynoms an verschiedenen Stellen von $\alpha^i$ ergibt ihre Fouriertransformierte $a(x)$

$\displaystyle{
    a_i = A(\alpha^i)
}$

\textbf{Zyklische Faltung}

Polynommultiplikation im Galois-Feld $\rightarrow$ zyklische Faltung

Normale Faltung mit endlichen Signalen $\rightarrow$ endliches Faltungsergebnis

Zyklische Faltung: Signale sind periodisch, damit Faltungsergebnis ebenfalls periodisch (und damit unendlich lang)

\includegraphics[width=8.7cm]{img/zykische_faltung.PNG}

links: zyklische Faltung \;\;\;\;\;\;\;\;\;\;\;\; rechts: normale Faltung

\section{Reed-Solomon-Code}

\subsection{Wunsch und Idee}

\textbf{Wunsch}

Konstruktion eines Codes mit vorgegebener Korrekturfähigkeit\\
$\rightarrow$ Vorgabe des Mindestabstandes $d$

$\displaystyle{
    e = \Bigl\lfloor \frac{d - 1}{2} \Bigr\rfloor
}$\\
$\displaystyle{
    d = 2e + 1
}$

bei linearem Code ist Mindestabstand = Mindestgewicht

$\rightarrow$ Codeworte haben mind. $d$ von 0 verschiedene Koeffizienten

d'Alembert: Polynom vom Grad $n$ hat $n$ komplexe (oder höchstens $n$ reelle) Nullstellen; auch
im Galois-Feld

\textbf{Idee}

Konstruktion des Informationswortes als Polynom $A(x)$ mit Grad $k-1$ (damit höchstens $k-1$ Nullstellen)

Im $GF(p)$ mit Ordnung $n = p-1$ kann man $A(x)$ an $n$ Stellen auswerten, danach wiederholen sich die Werte

$\rightarrow$ Auswertung des Polynoms für verschiedene $x$ (bzw. $\alpha^i$) ergeben die Koeffizienten $a_i$ des
Polynoms $a(x)$

$\displaystyle{
    a_i = A(\alpha^i) \qquad\qquad \text{IDFT}
}$

von diesen sind höchstens $k-1$ Null (weil $grad(A(x)) = k-1$)\\
von diesen sind also mind. $n - (k-1)$ von Null verschieden $\rightarrow$ Mindestgewicht $d$

$d = n - (k - 1) = n - k + 1$

\subsection{Codierung}

Verschiedene Möglichkeiten aus einem Informationswort ein Codewort zu generieren

\subsubsection{Generatorpolynom}

$\displaystyle{
    g(x) = \prod_{i=k}^{n-1} \left(x - \alpha^{-i}\right)
}$

Syndromstellen beginnen hier bei $k$, es sind aber alle anderen Stellen möglich, solange sie zusammenhängen

$grad(g(x)) = d-1 = n-k$ = Anzahl Syndromstellen

$g(x)$: Generatorpolynom\\
$i(x)$: Informationspolynom

\subsubsection{IDFT (nicht systematisch)}

$\displaystyle{
    a_i = A(\alpha^i)
}$

$A(x)$: Informationswort\\
$a_i$: Koeff. des Codewortes

\subsubsection{Polynommultiplikation (nicht systematisch)}

$\displaystyle{
    a_i = g(x) \cdot i(x)
}$

\subsubsection{Polynomdivision (systematisch)}

Informationswort ist Teil des Codewortes (an den hohen Potenzen)

$\displaystyle{
    a^*(x) = i_{k-1} x^{n-1} + i_{k-2} x^{n-2} + ... + i_1 x^{n-k+1} + i_0 x^{n-k}
}$

jedes Codewort muss durch Generatorpolynom teilbar sein $\rightarrow$ ist
für $a^*(x)$ i.A. nicht der Fall

$\displaystyle{
    \frac{a^*(x)}{g(x)} = b(x) + \frac{rest(a^*(x))}{g(x)}
}$\\
$\displaystyle{
    \rightarrow \frac{a^*(x) - rest\left(a^*(x)\right)}{g(x)} = b(x)
}$\\
$\displaystyle{
    a(x) = a^*(x) - rest\left(a^*(x)\right)
}$

$rest\left(a^*(x)\right)$: Divisionsrest

\subsubsection{Über Prüfpolynom (systematisch)}

Prüfpolynom:

$\displaystyle{
    h(x) = \prod_{i=0}^{k-1} \left(x - \alpha^{-i}\right)
}$

Produkt aus Generator- und Prüfpolynom ist 0

$\displaystyle{
    g(x) \cdot h(x) = 0
}$

und Produkt aus Codepolynom und Prüfpolynom ist 0

$\displaystyle{
    a(x) \cdot h(x) = 0
}$

genau da, wo $g(x)$ (oder $a(x)$) Nullstellen hat (also $G_i$ 0 ist) hat das Prüfpolynom $h(x)$ keine Nullstellen
(ist also $H_i$ nicht 0) und umgekehrt

\subsubsection{Zyklischer Code}

Multiplikation eines Polynoms mit $x^i$ verschiebt Koeff. des Polynoms um $i$-Stellen

durch mod-Rechnung des Exponenten verschieben sich höhere Exponenten wieder an den Anfang des Polynoms

Bsp.:

$\displaystyle{
    x \cdot a(x) = x \cdot ( 2x^2 + x + 1 ) = 2x^3 + x^2 + x = x^2 + x + 2
}$

\subsection{Decodierung}

\textbf{Idee:}

Addition des Fehlerpolynoms $f(x)$ mit $t$ Koeffizienten (d.h. $t$ Fehler sind auf dem Kanal aufgetreten)
zum gesendeten Codewort $a(x)$

im Zeitbereich:

$\displaystyle{
    r(x) = a(x) + f(x)
}$

im Frequenzbereich:

$\displaystyle{
    R(x) = A(x) + F(x)
}$

gedanklich wird ein Polynom $c(x)$ aufgestellt, welches $t$ Nullen an den Fehlerstellen hat

Da die Koeffizienten von $c(x)$ die Auswertung ihrer Fouriertransformierten $C(x)$ ist, ist der Grad
von $C(x)$ $t$

Da $c(x)$ gerade dort 0 ist, wo $f(x)$ ungleich 0, ist das Produkt $f_i \cdot c_i$ immer 0 (Achtung, keine
Polynommultiplikation gemeint, sondern punktweise Multiplikation)

$\displaystyle{
    f_i \cdot c_i = 0
}$

wenn Zeitbereich = 0 $\rightarrow$ Frequenzbereich = 0

$\displaystyle{
    F(x) \cdot C(x) = 0
}$

Achtung: hier Polynommultiplikation/ Faltung/ Filterung gemeint\\
$\hookrightarrow$ Aufstellen der Schlüsselgleichungen

\includegraphics[width=8cm]{img/decod_rs.PNG}

\subsubsection{Vorgehen}

\begin{enumerate}
    \item Fouriertransformation des empfangenen Codewortes $r(x) \rightarrow R(x)$
    \item Auslesen der Koeff. des Syndrompolynoms ($S_0, ..., S_n$) aus $R(x)$ und Aufstellen des Syndrompolynoms
    \item Berechnung des $C(x)$ aus Schlüsselgleichungen oder euklidschem Algorithmus
    \item Berechnung der Fehlerstellen durch Nullstellensuche von $C(x)$
    \item Berechnung des Fehlerwertes über Schlüsselgleichungen oder Forney-Algorithmus
\end{enumerate}

\subsubsection{Schlüsselgleichungen}

beschreiben, dass Faltung von $C(x)$ und $F(x)$ Null ist (Achtung: zyklische Faltung, siehe \autoref{sec:galois})

$F_0$ bis $F_{n-k-1}$ (bzw. $F_{d-2}$) sind bekannt, da diese direkt an den Syndromstellen
von $R(x)$ stehen

Alle $C$-Koeff. sind unbekannt, außer $C_{t}$, dieser wird zu $1$ gesetzt

$\displaystyle{
    C_{t} = 1
}$

da Anzahl der Fehler ($t$) unbekannt ist, muss ausprobiert werden, welche \underline{minimale} Anzahl an Fehlern
die Schlüsselgleichungen widerspruchsfrei erfüllt

Lösen der Schlüsselgleichungen nach $C(x)$

$\hookrightarrow$ Nullstellensuche von $C(x)$ ergibt die Nullen des $c(x)$

$\hookrightarrow$ wenn Grad von $C(x)$ nicht mit Anzahl der Nullstellen übereinstimmt $\rightarrow$ Decodierversagen

Lösen der Schlüsselgleichungen nach $F(x)$

$\hookrightarrow f(x)$ aus Rücktransformation von $F(x)$

$\hookrightarrow f(x)$ von $r(x)$ abziehen, man erhält $a(x)$

$\displaystyle{
    a(x) = r(x) - f(x)
}$

%%// TODO: Schlüsselgleichungen aufstellen und eigentliche Schlüsselgleichungen

\subsubsection{Euklidscher Algorithmus}

Suche des ggT zweier Zahlen

Kann zur Lösung der Schlüsselgleichungen verwendet werden

Rest:

$\displaystyle{
    r_n = v_n a_n + w_n b_n
}$

Rekursionsformeln für $v_n$ und $w_n$:

$\displaystyle{
    v_n = v_{n-2} - q_n v_{n-1}
}$

$\displaystyle{
    w_n = w_{n-2} - q_n w_{n-1}
}$

$q_n$: Quotient des vorherigen Schrittes

Initialisierung:

$\displaystyle{
    v_{-1} = 1 \;\;\;\;\; v_0 = 0
}$\\
$\displaystyle{
    w_{-1} = 0 \;\;\;\;\; w_0 = 1
}$

Suche des $C(x)$ und damit den Fehlerstellen

Polynomdivision von $x^{d-1}$ und des Syndrompolynoms $S(x)$

$\displaystyle{
    x^{d-1} : S(x)
}$

Wenn Rest der Division im Grad nicht kleiner ist als die Anzahl der Fehler $e$, die maximal korrigiert
werden können $\rightarrow$ weiter: $S(x) : r_1(x)$

usw.

ist Grad des Restes kleiner als $e$ $\rightarrow$ Berechnung des $C(x)$ und des $T(x)$

$\hookrightarrow C(x) = w_n$

$\hookrightarrow T(x) = -r_n$

\subsubsection{Forney-Algorithmus}

Fehlerwertberechnung aus gegebenem $C(x)$ und $T(x)$

$\displaystyle{
    f_i = x^q \cdot n \cdot x^{-1} \frac{T(x)}{C'(x)}\bigg \vert_{x=\alpha^i}
}$

$q$: Verschiebung der Syndromstellen ($q=5$, wenn Syndrom an Stelle 5)

\underline{Achtung}: Fehlerwert an den Stellen, an dem \underline{keine} Fehler passiert sind, ist i.A.
\underline{nicht} 0

\subsection{Kürzere Codes}

\textbf{Verkürzung}

Streichen von Informationswortstellen und Codewortstellen

Distanz und damit Fehlerkorrigierbarkeit bleibt gleich

Code ist nicht mehr zyklisch

Bsp.: Verkürzung eines $C(6, 2, 5)$ um 1 auf $C(5, 1, 5)$

\textbf{Punktierung}

%//TODO

\section{Erweiterungskörper}

\subsection{Idee}

Erweitern des Grundkörpers (z.B. $2$) mit Exponent (z.B. $4$) $\rightarrow$
$GF(2^4)$

Irreduzibles Polynom ist die Primzahl des Erweiterungskörpers z.B. in $GF(2^4)$:\\
$\displaystyle{
    p(x) = x^4 + x + 1
}$

Irreduzibles Polynom: $ggT(p(x), b(x)) = 1$

größter gemeinsamer Teiler mit einem beliebigen Polynom $b(x)$ ist 1

d.h. $p(x)$ kann nicht in Linearfaktoren zerlegt werden

für irreduzible Polynome gilt:\\
- ist durch kein Polynom ohne Rest teilbar\\
- hat keine Nullstellen

\textbf{aber:} Nullstellen sind wichtig für Nutzung des RS-Codes, daher \flqq Erfindung\flqq{} des
Elements $\alpha$, welches Nullstelle von $p(x)$ ist

$\displaystyle{
    p(\alpha) = 0
}$

am Beispiel:\\
$\displaystyle{
    p(\alpha) = \alpha^4 + \alpha + 1 = 0
}$

Analogie: \flqq Erfindung\flqq{} von $j$, sodass gilt:

$\displaystyle{
    j^2 + 1 = 0
}$

primitives Polynom: Nullstelle ($\alpha$) des primitiven Polynoms erzeugt alle Elemente (außer 0) des Erweiterungskörpers

primitives Element: Nullstelle $\alpha$ des primitiven Polynoms

\subsection{Eigenschaften von Erweiterungskörpern}

Ordnung des primitiven Elements: $2^m - 1$ im $GF(2^m)$

Erzeugung der Elemente über Potenzieren des primitiven Elements $\alpha$

zum Körper $GF(2^m)$ gehören $2^m$ Elemente ($2^m - 1$ dieser wird durch Potenzieren von $\alpha$ erzeugt)

Elemente der Erweiterungskörper sind Polynome

\textbf{Darstellung}

Erzeugung von bspw. $\alpha^3$ in $GF(2^4)$ mit irreduziblem Polynom $p(x) = x^4 + x + 1$:

$\displaystyle{
    \alpha^3 = 1 \cdot \alpha^3 + 0 \cdot \alpha^2 + 0 \cdot \alpha^1 + 0 \cdot \alpha^0
}$

dazugehörige Binärdarstellung:

$1000$

\section{BCH-Codes}

\subsection{Idee}

Für Erweiterungskörper war $\alpha$ die Nullstelle des primitiven Polynoms

ABER: d'Alembert: Polynom vom Grad $m$ hat $m$ Nullstellen

Wo sind die restlichen Nullstellen der primitiven Polynome höheren Grades?

$\hookrightarrow$ wenn $\alpha$ Nullstelle von $p(x)$ ist, dann sind auch $\alpha^2, \alpha^{2^2}, \alpha^{2^3}, ..., \alpha^{2^{m-1}}$
Nullstellen ($\rightarrow$ konjugiert komplexe Nullstellen)

\subsection{Kreisteilungsklassen}

\section{Faltungscodes}

Filterung der Eingangssequenz mit FIR-Filter

Beschreibung durch $C(n, k, [z])$

$n$: Anzahl Ausgänge\\
$k$: Anzahl Eingänge\\
$z$: Anzahl an Speicherzellen

\subsection{Ein Ausgang}

Faltungscoder ohne Redundanz

Normaler FIR-Filter mit binären Koeffizienten, Generatorsequenz ist Impulsantort

Delay: $z^{-1} = D$

Impulsantort: $\vec{g}$

Inhalt der Speicherzellen: $\vec{d}$

Ausgang: $\displaystyle{
    a = \vec{g} \cdot
    \begin{pmatrix}
        i\\
        \vec{d}
    \end{pmatrix}
}$

\textbf{Beispiel}

\includegraphics[width=7cm]{img/faltungscoder1in1out.PNG}

Impulsantort: $\displaystyle{
    g = 1 + 1D + 0D^2 + D^3 = 1 + D + D^3
}$

Generatorsequenz: $\displaystyle{\vec{g}^T =
    \begin{pmatrix}
        1 & 1 & 0 & 1
    \end{pmatrix}
}$

Von links nach rechts steht \textcolor{red}{$ (1 0 0) $} in den Speicherzellen und es wird $i = 1$ hineingeschrieben

$\displaystyle{
    \hookrightarrow \vec{d} = \begin{pmatrix}
        1\\
        0\\
        0
    \end{pmatrix}
}$

$\displaystyle{
    a = \begin{pmatrix}
        1 & 1 & 0 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1\\
        1\\
        0\\
        0
    \end{pmatrix}
    = 0    
}$

\subsection{Mehrere Ausgänge}

Filter mit mehreren Ausgängen

2 Impulsantorten des Filters geben 2 verschiedene Ausgänge

Generatorsequenz wird zu Generatormatrix mit 2 Generatorsequenzen

$\displaystyle{
    \vec{a} = G^T \cdot
    \begin{pmatrix}
        i\\
        \vec{d}
    \end{pmatrix} =
    \begin{pmatrix}
        a_1\\
        a_2
    \end{pmatrix}
}$\;\;\;\;\;\;\;\;\;\;\;\;\;
$\displaystyle{
    G =
    \begin{pmatrix}
        \vec{g_1}^T\\
        \vec{g_2}^T
    \end{pmatrix}
}$

\textbf{Beispiel}

\includegraphics[width=7cm]{img/faltungscoder1in2out.PNG}

Im Speicher steht wieder von links nach rechts \textcolor{red}{$ (1 0 0) $} und es wird $i = 1$ hineingeschrieben

$\displaystyle{
    \vec{a} =
    \begin{pmatrix}
        1 & 1 & 0 & 1\\
        1 & 1 & 1 & 1
    \end{pmatrix}
    \cdot
    \begin{pmatrix}
        1\\
        1\\
        0\\
        0
    \end{pmatrix} =
    \begin{pmatrix}
        0\\
        0
    \end{pmatrix}
}$

\subsection{Mehrere Ausgänge}

Mehrere Eingänge ($i_1, i_2$) um Coderate anzupassen

für jeden Ausgang gibt es jeweils 2 Generatorsequenzen ($g_{ij}$)

$i$: Eingang\\
$j$: Ausgang

\textbf{Beispiel}

\includegraphics[width=7cm]{img/faltungscoder2in3out.PNG}

$\displaystyle{
    \vec{g_{11}}^T = \begin{pmatrix}
        1 & 1 & 0 & 1
    \end{pmatrix}
    \;\;\;\;\;\;\;
    \vec{g_{21}}^T = \begin{pmatrix}
        0 & 0 & 0 & 0
    \end{pmatrix}
}$

$\displaystyle{
    \vec{g_{12}}^T = \begin{pmatrix}
        1 & 1 & 1 & 1
    \end{pmatrix}
    \;\;\;\;\;\;\;
    \vec{g_{22}}^T = \begin{pmatrix}
        0 & 0 & 1 & 0
    \end{pmatrix}
}$

$\displaystyle{
    \vec{g_{13}}^T = \begin{pmatrix}
        0 & 0 & 0 & 1
    \end{pmatrix}
    \;\;\;\;\;\;\;
    \vec{g_{23}}^T = \begin{pmatrix}
        0 & 1 & 1 & 0
    \end{pmatrix}
}$
\\

Zusamenfassung in $G$

\begin{equation*}
    G = 
    \begin{tikzpicture}[baseline={-0.5ex},mymatrixenv]
        \matrix [mymatrix,inner sep=4pt] (m)  
        {
            1 & 0 & 1 & 0 & 0 & 0 & 1 & 0\\
            1 & 0 & 1 & 0 & 1 & 1 & 1 & 0\\
            0 & 0 & 0 & 1 & 0 & 1 & 1 & 0\\
        };
    
        % Braces
        \mymatrixbracebottom{2}{1}{$D^0$}
        \mymatrixbracebottom{4}{3}{$D^1$}
        \mymatrixbracebottom{6}{5}{$D^2$}
        \mymatrixbracebottom{8}{7}{$D^3$}
        \mymatrixbraceleft{1}{1}{Ausgang 1}
        \mymatrixbraceleft{2}{2}{Ausgang 2}
        \mymatrixbraceleft{3}{3}{Ausgang 3}
        \mymatrixbracetop{1}{1}{E1}
        \mymatrixbracetop{2}{2}{E2}
        \mymatrixbracetop{3}{3}{E1}
        \mymatrixbracetop{4}{4}{E2}
        \mymatrixbracetop{5}{5}{E1}
        \mymatrixbracetop{6}{6}{E2}
        \mymatrixbracetop{7}{7}{E1}
        \mymatrixbracetop{8}{8}{E2}
    \end{tikzpicture}
\end{equation*}
